Cell.size = as.numeric(Cell.size),
Cell.shape = as.numeric(Cell.shape),
Marg.adhesion = as.numeric(Marg.adhesion),
Epith.c.size = as.numeric(Epith.c.size),
Bare.nuclei = as.numeric(Bare.nuclei),
Bl.cromatin = as.numeric(Bl.cromatin),
Normal.nucleoli = as.numeric(Normal.nucleoli),
Mitoses = as.numeric(Mitoses))
BreastCancer_num[is.na(BreastCancer_num)] = 0
#calculate correlation matrix using pearson correlation (others include spearman and kendall)
correlation_matrix = cor(BreastCancer_num[,1:10])
#visualize correlation matrix
library(corrplot)
corrplot(correlation_matrix, order = "hclust")
#apply correlation filter of 0.7
highly_correlated <- colnames(BreastCancer[, -1])[findCorrelation(correlation_matrix, cutoff = 0.7, verbose = TRUE)]
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(caret)
library(randomForest)
library(mlbench)
library(glmnet)
data(BreastCancer)
head(BreastCancer)
dim(BreastCancer)
summary(BreastCancer$Class)
BreastCancer_num = transform(BreastCancer, Id = as.numeric(Id),
Cl.thickness = as.numeric(Cl.thickness),
Cell.size = as.numeric(Cell.size),
Cell.shape = as.numeric(Cell.shape),
Marg.adhesion = as.numeric(Marg.adhesion),
Epith.c.size = as.numeric(Epith.c.size),
Bare.nuclei = as.numeric(Bare.nuclei),
Bl.cromatin = as.numeric(Bl.cromatin),
Normal.nucleoli = as.numeric(Normal.nucleoli),
Mitoses = as.numeric(Mitoses))
BreastCancer_num[is.na(BreastCancer_num)] = 0
#calculate correlation matrix using pearson correlation (others include spearman and kendall)
correlation_matrix = cor(BreastCancer_num[,1:10])
#visualize correlation matrix
library(corrplot)
corrplot(correlation_matrix, order = "hclust")
#apply correlation filter of 0.7
highly_correlated <- colnames(BreastCancer[, -1])[findCorrelation(correlation_matrix, cutoff = 0.7, verbose = TRUE)]
#which features are highly correlated and can be removed
highly_correlated
data(BreastCancer)
BreastCancer_num = transform(BreastCancer, Id = as.numeric(Id),
Cl.thickness = as.numeric(Cl.thickness),
Cell.size = as.numeric(Cell.size),
Cell.shape = as.numeric(Cell.shape),
Marg.adhesion = as.numeric(Marg.adhesion),
Epith.c.size = as.numeric(Epith.c.size),
Bare.nuclei = as.numeric(Bare.nuclei),
Bl.cromatin = as.numeric(Bl.cromatin),
Normal.nucleoli = as.numeric(Normal.nucleoli),
Mitoses = as.numeric(Mitoses))
BreastCancer_num[is.na(BreastCancer_num)] = 0
#define the control
control = rfeControl(functions = caretFuncs, number = 2)
# run the RFE algorithm
results = rfe(BreastCancer_num[,1:10], BreastCancer_num[,11], sizes = c(2,5,9), rfeControl = control, method = "svmRadial")
results
results$variables
set.seed(24)
#convert data
x = x <- as.matrix(BreastCancer_num[,1:10])
y = as.double(as.matrix(ifelse(BreastCancer_num[,11]=='benign', 0, 1)))
#fit Lasso model
cv.lasso <- cv.glmnet(x, y, family='binomial', alpha=1, parallel=TRUE, standardize=TRUE, type.measure='auc')
plot(cv.lasso)
cat('Min Lambda: ', cv.lasso$lambda.min, '\n 1Sd Lambda: ', cv.lasso$lambda.1se)
df_coef <- round(as.matrix(coef(cv.lasso, s=cv.lasso$lambda.min)), 2)
# See all contributing variables
df_coef[df_coef[, 1] != 0, ]
#data
data(BreastCancer)
train_size <- floor(0.75 * nrow(BreastCancer))
set.seed(24)
train_pos <- sample(seq_len(nrow(BreastCancer)), size = train_size)
#convert to numeric
BreastCancer_num = transform(BreastCancer, Id = as.numeric(Id),
Cl.thickness = as.numeric(Cl.thickness),
Cell.size = as.numeric(Cell.size),
Cell.shape = as.numeric(Cell.shape),
Marg.adhesion = as.numeric(Marg.adhesion),
Epith.c.size = as.numeric(Epith.c.size),
Bare.nuclei = as.numeric(Bare.nuclei),
Bl.cromatin = as.numeric(Bl.cromatin),
Normal.nucleoli = as.numeric(Normal.nucleoli),
Mitoses = as.numeric(Mitoses))
BreastCancer_num[is.na(BreastCancer_num)] = 0
train_classification <- BreastCancer_num[train_pos, ]
test_classification <- BreastCancer_num[-train_pos, ]
#fit a model
rfmodel = randomForest(Class ~ Id + Cl.thickness + Cell.size + Cell.shape + Marg.adhesion + Epith.c.size + Bare.nuclei + Bl.cromatin + Normal.nucleoli +  Mitoses, data=train_classification,  importance = TRUE, oob.times = 15, confusion = TRUE)
#rank features based on importance
importance(rfmodel)
data(BreastCancer)
BreastCancer_num = transform(BreastCancer, Id = as.numeric(Id),
Cl.thickness = as.numeric(Cl.thickness),
Cell.size = as.numeric(Cell.size),
Cell.shape = as.numeric(Cell.shape),
Marg.adhesion = as.numeric(Marg.adhesion),
Epith.c.size = as.numeric(Epith.c.size),
Bare.nuclei = as.numeric(Bare.nuclei),
Bl.cromatin = as.numeric(Bl.cromatin),
Normal.nucleoli = as.numeric(Normal.nucleoli),
Mitoses = as.numeric(Mitoses))
BreastCancer_num[is.na(BreastCancer_num)] = 0
#define the control
control = rfeControl(functions = caretFuncs, number = 2)
# run the RFE algorithm
results = rfe(BreastCancer_num[,1:10], BreastCancer_num[,11], sizes = c(2,5,9), rfeControl = control, method = "svmRadial")
data(BreastCancer)
BreastCancer_num = transform(BreastCancer, Id = as.numeric(Id),
Cl.thickness = as.numeric(Cl.thickness),
Cell.size = as.numeric(Cell.size),
Cell.shape = as.numeric(Cell.shape),
Marg.adhesion = as.numeric(Marg.adhesion),
Epith.c.size = as.numeric(Epith.c.size),
Bare.nuclei = as.numeric(Bare.nuclei),
Bl.cromatin = as.numeric(Bl.cromatin),
Normal.nucleoli = as.numeric(Normal.nucleoli),
Mitoses = as.numeric(Mitoses))
BreastCancer_num[is.na(BreastCancer_num)] = 0
#define the control
control = rfeControl(functions = caretFuncs, number = 2)
# run the RFE algorithm
results = rfe(BreastCancer_num[,1:10], BreastCancer_num[,11], sizes = c(2,5,9), rfeControl = control, method = "svmRadial")
#sizes (2,5,9) can try different numbers
results
results$variables
#visualized
plot(results, type=c('g','o'))
#list chosen features
predictors(results)
set.seed(24)
#convert data to matrix
x = as.matrix(BreastCancer_num[,1:10])
y = as.double(as.matrix(ifelse(BreastCancer_num[,11]=='benign', 0, 1)))
#fit Lasso model
cv.lasso <- cv.glmnet(x, y, family='binomial', alpha=1, parallel=TRUE, standardize=TRUE, type.measure='auc')
plot(cv.lasso)
cat('Min Lambda: ', cv.lasso$lambda.min, '\n 1Sd Lambda: ', cv.lasso$lambda.1se)
df_coef <- round(as.matrix(coef(cv.lasso, s=cv.lasso$lambda.min)), 2)
# See all contributing variables
df_coef[df_coef[, 1] != 0, ]
#data
data(BreastCancer)
train_size <- floor(0.75 * nrow(BreastCancer))
set.seed(24)
train_pos <- sample(seq_len(nrow(BreastCancer)), size = train_size)
#convert to numeric
BreastCancer_num = transform(BreastCancer, Id = as.numeric(Id),
Cl.thickness = as.numeric(Cl.thickness),
Cell.size = as.numeric(Cell.size),
Cell.shape = as.numeric(Cell.shape),
Marg.adhesion = as.numeric(Marg.adhesion),
Epith.c.size = as.numeric(Epith.c.size),
Bare.nuclei = as.numeric(Bare.nuclei),
Bl.cromatin = as.numeric(Bl.cromatin),
Normal.nucleoli = as.numeric(Normal.nucleoli),
Mitoses = as.numeric(Mitoses))
BreastCancer_num[is.na(BreastCancer_num)] = 0
train_classification <- BreastCancer_num[train_pos, ]
test_classification <- BreastCancer_num[-train_pos, ]
#fit a model
rfmodel = randomForest(Class ~ Id + Cl.thickness + Cell.size + Cell.shape + Marg.adhesion + Epith.c.size + Bare.nuclei + Bl.cromatin + Normal.nucleoli +  Mitoses, data=train_classification,  importance = TRUE, oob.times = 15, confusion = TRUE)
#rank features based on importance
importance(rfmodel)
data(BostonHousing)
head(BostonHousing)
dim(BostonHousing)
summary(BostonHousing$Class)
data(BostonHousing)
head(BostonHousing)
dim(BostonHousing)
BostonHousing_num = transform(BostonHousing, crim = as.numeric(crim),
zn = as.numeric(zn),
indus = as.numeric(indus),
chas = as.numeric(chas),
nox = as.numeric(nox),
rm = as.numeric(rm),
age = as.numeric(age),
dis = as.numeric(dis),
rad = as.numeric(rad),
tax = as.numeric(tax),
ptratio = as.numeric(ptratio),
b = as.numeric(b),
lstat = as.numeric(lstat),
medv = as.numeric(medv))
BostonHousing_num[is.na(BostonHousing_num)] = 0
#calculate correlation matrix using pearson correlation (others include spearman and kendall)
correlation_matrix = cor(BostonHousing_num[,1:10])
#visualize correlation matrix
library(corrplot)
corrplot(correlation_matrix, order = "hclust")
#apply correlation filter of 0.7
highly_correlated <- colnames(BostonHousing[, -1])[findCorrelation(correlation_matrix, cutoff = 0.7, verbose = TRUE)]
#which features are highly correlated and can be removed
highly_correlated
#define the control
control = rfeControl(functions = caretFuncs, number = 2)
# run the RFE algorithm
results = rfe(BreastCancer_num[,1:10], BreastCancer_num[,11], sizes = c(2,5,9), rfeControl = control, method = "svmRadial")
#sizes (2,5,9)/(2,5,7) can try different numbers
results
results$variables
#visualized
plot(results, type=c('g','o'))
#list chosen features
predictors(results)
#define the control
control = rfeControl(functions = caretFuncs, number = 2)
# run the RFE algorithm
results = rfe(BostonHousing_num[,1:10], BostonHousing_num[,11], sizes = c(2,5,9), rfeControl = control, method = "svmRadial")
#sizes (2,5,9)/(2,5,7) can try different numbers
results
results$variables
#visualized
plot(results, type=c('g','o'))
#list chosen features
predictors(results)
#calculate correlation matrix using pearson correlation (others include spearman and kendall)
correlation_matrix = cor(BostonHousing_num[,1:10])
#visualize correlation matrix
library(corrplot)
corrplot(correlation_matrix, order = "hclust")
#apply correlation filter of 0.7
highly_correlated <- colnames(BostonHousing[, -1])[findCorrelation(correlation_matrix, cutoff = 0.7, verbose = TRUE)]
#which features are highly correlated and can be removed
highly_correlated
#define the control
control = rfeControl(functions = caretFuncs, number = 2)
# run the RFE algorithm
results = rfe(BostonHousing_num[,1:14], BostonHousing_num[,15], sizes = c(2,5,9), rfeControl = control, method = "svmRadial")
#define the control
control = rfeControl(functions = caretFuncs, number = 2)
# run the RFE algorithm
results = rfe(BostonHousing_num[,1:14], BostonHousing_num[,14], sizes = c(2,5,9), rfeControl = control, method = "svmRadial")
#sizes (2,5,9)/(2,5,7) can try different numbers
results
results$variables
#visualized
plot(results, type=c('g','o'))
#list chosen features
predictors(results)
#calculate correlation matrix using pearson correlation (others include spearman and kendall)
correlation_matrix = cor(BostonHousing_num[,1:14])
#visualize correlation matrix
library(corrplot)
corrplot(correlation_matrix, order = "hclust")
#apply correlation filter of 0.7
highly_correlated <- colnames(BostonHousing[, -1])[findCorrelation(correlation_matrix, cutoff = 0.7, verbose = TRUE)]
#which features are highly correlated and can be removed
highly_correlated
#loading data
data(Glass)
head(Glass)
dim(Glass)
#loading data
data(Glass)
# head(Glass)
# dim(Glass)
#loading data
data(Glass)
# head(Glass)
# dim(Glass)
data
#loading data
data(Glass)
# head(Glass)
# dim(Glass)
Glass
Glass_num = transform(Glass, RI = as.numeric(RI),
Na = as.numeric(Na),
Mg = as.numeric(Mg),
Al = as.numeric(Al),
Si = as.numeric(Si),
K = as.numeric(K),
Ca = as.numeric(Ca),
Ba = as.numeric(Ba),
Fe = as.numeric(Fe),
Type = as.numeric(Type))
Glass_num[is.na(Glass_num)] = 0
#calculate correlation matrix using pearson correlation (others include spearman and kendall)
correlation_matrix = cor(Glass_num[,1:10])
#visualize correlation matrix
library(corrplot)
corrplot(correlation_matrix, order = "hclust")
#apply correlation filter of 0.7
highly_correlated <- colnames(Glass_num[, -1])[findCorrelation(correlation_matrix, cutoff = 0.7, verbose = TRUE)]
#which features are highly correlated and can be removed
highly_correlated
#"chas"    "ptratio" "rm"      "medv"    "rad"
#define the control
control = rfeControl(functions = caretFuncs, number = 2)
# run the RFE algorithm
results = rfe(Glass_num[,1:10], BostonHousing_num[,10], sizes = c(2,5,9), rfeControl = control, method = "svmRadial")
#define the control
control = rfeControl(functions = caretFuncs, number = 2)
# run the RFE algorithm
results = rfe(Glass_num[,1:10], BostonHousing_num[,10], sizes = c(2,5,7), rfeControl = control, method = "svmRadial")
#define the control
control = rfeControl(functions = caretFuncs, number = 2)
# run the RFE algorithm
results = rfe(Glass_num[,1:10], Glass_num[,10], sizes = c(2,5,7), rfeControl = control, method = "svmRadial")
#sizes (2,5,9)/(2,5,7) can try different numbers
results
results$variables
#visualized
plot(results, type=c('g','o'))
#list chosen features
predictors(results)
#"medv"  "lstat"
#calculate correlation matrix using pearson correlation (others include spearman and kendall)
correlation_matrix = cor(Glass_num[,1:11])
#calculate correlation matrix using pearson correlation (others include spearman and kendall)
correlation_matrix = cor(Glass_num[,1:9])
#visualize correlation matrix
library(corrplot)
corrplot(correlation_matrix, order = "hclust")
#apply correlation filter of 0.7
highly_correlated <- colnames(Glass_num[, -1])[findCorrelation(correlation_matrix, cutoff = 0.7, verbose = TRUE)]
#which features are highly correlated and can be removed
highly_correlated
#"chas"    "ptratio" "rm"      "medv"    "rad"
#calculate correlation matrix using pearson correlation (others include spearman and kendall)
correlation_matrix = cor(Glass_num[,1:10])
#visualize correlation matrix
library(corrplot)
corrplot(correlation_matrix, order = "hclust")
#apply correlation filter of 0.7
highly_correlated <- colnames(Glass_num[, -1])[findCorrelation(correlation_matrix, cutoff = 0.7, verbose = TRUE)]
#which features are highly correlated and can be removed
highly_correlated
#"chas"    "ptratio" "rm"      "medv"    "rad"
#calculate correlation matrix using pearson correlation (others include spearman and kendall)
correlation_matrix = cor(Glass_num[,1:10])
#visualize correlation matrix
library(corrplot)
corrplot(correlation_matrix, order = "hclust")
#apply correlation filter of 0.7
highly_correlated <- colnames(Glass_num[, -1])[findCorrelation(correlation_matrix, cutoff = 0.7, verbose = TRUE)]
#which features are highly correlated and can be removed
highly_correlated
#define the control
control = rfeControl(functions = caretFuncs, number = 2)
# run the RFE algorithm
results = rfe(Glass_num[,1:10], Glass_num[,10], sizes = c(2,5,7), rfeControl = control, method = "svmRadial")
#sizes (2,5,9)/(2,5,7) can try different numbers
results
results$variables
#visualized
plot(results, type=c('g','o'))
#list chosen features
predictors(results)
#"medv"  "lstat"
#define the control
control = rfeControl(functions = caretFuncs, number = 2)
# run the RFE algorithm
results = rfe(Glass_num[,1:10], Glass_num[,10], sizes = c(1,3,5), rfeControl = control, method = "svmRadial")
#sizes (2,5,9)/(2,5,7) can try different numbers
results
results$variables
#visualized
plot(results, type=c('g','o'))
#list chosen features
predictors(results)
#define the control
control = rfeControl(functions = caretFuncs, number = 2)
# run the RFE algorithm
results = rfe(Glass_num[,1:9], Glass_num[,9], sizes = c(1,3,5), rfeControl = control, method = "svmRadial")
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(caret)
library(randomForest)
library(mlbench)
library(glmnet)
data(BreastCancer)
head(BreastCancer)
dim(BreastCancer)
summary(BreastCancer$Class)
BreastCancer_num = transform(BreastCancer, Id = as.numeric(Id),
Cl.thickness = as.numeric(Cl.thickness),
Cell.size = as.numeric(Cell.size),
Cell.shape = as.numeric(Cell.shape),
Marg.adhesion = as.numeric(Marg.adhesion),
Epith.c.size = as.numeric(Epith.c.size),
Bare.nuclei = as.numeric(Bare.nuclei),
Bl.cromatin = as.numeric(Bl.cromatin),
Normal.nucleoli = as.numeric(Normal.nucleoli),
Mitoses = as.numeric(Mitoses))
BreastCancer_num[is.na(BreastCancer_num)] = 0
#calculate correlation matrix using pearson correlation (others include spearman and kendall)
correlation_matrix = cor(BreastCancer_num[,1:10])
#visualize correlation matrix
library(corrplot)
corrplot(correlation_matrix, order = "hclust")
#apply correlation filter of 0.7
highly_correlated <- colnames(BreastCancer[, -1])[findCorrelation(correlation_matrix, cutoff = 0.7, verbose = TRUE)]
#which features are highly correlated and can be removed
highly_correlated
data(BreastCancer)
BreastCancer_num = transform(BreastCancer, Id = as.numeric(Id),
Cl.thickness = as.numeric(Cl.thickness),
Cell.size = as.numeric(Cell.size),
Cell.shape = as.numeric(Cell.shape),
Marg.adhesion = as.numeric(Marg.adhesion),
Epith.c.size = as.numeric(Epith.c.size),
Bare.nuclei = as.numeric(Bare.nuclei),
Bl.cromatin = as.numeric(Bl.cromatin),
Normal.nucleoli = as.numeric(Normal.nucleoli),
Mitoses = as.numeric(Mitoses))
BreastCancer_num[is.na(BreastCancer_num)] = 0
#define the control
control = rfeControl(functions = caretFuncs, number = 2)
# run the RFE algorithm
results = rfe(BreastCancer_num[,1:10], BreastCancer_num[,11], sizes = c(2,5,9), rfeControl = control, method = "svmRadial")
#sizes (2,5,9)/(2,5,7) can try different numbers
results
results$variables
#visualized
plot(results, type=c('g','o'))
#list chosen features
predictors(results)
set.seed(24)
#convert data to matrix
x = as.matrix(BreastCancer_num[,1:10])
y = as.double(as.matrix(ifelse(BreastCancer_num[,11]=='benign', 0, 1)))
#fit Lasso model
cv.lasso <- cv.glmnet(x, y, family='binomial', alpha=1, parallel=TRUE, standardize=TRUE, type.measure='auc')
plot(cv.lasso)
#tells at which point accuracy decreases
cat('Min Lambda: ', cv.lasso$lambda.min, '\n 1Sd Lambda: ', cv.lasso$lambda.1se)
df_coef <- round(as.matrix(coef(cv.lasso, s=cv.lasso$lambda.min)), 2)
# See all contributing variables
df_coef[df_coef[, 1] != 0, ]
#data
data(BreastCancer)
train_size <- floor(0.75 * nrow(BreastCancer))
set.seed(24)
train_pos <- sample(seq_len(nrow(BreastCancer)), size = train_size)
#convert to numeric
BreastCancer_num = transform(BreastCancer, Id = as.numeric(Id),
Cl.thickness = as.numeric(Cl.thickness),
Cell.size = as.numeric(Cell.size),
Cell.shape = as.numeric(Cell.shape),
Marg.adhesion = as.numeric(Marg.adhesion),
Epith.c.size = as.numeric(Epith.c.size),
Bare.nuclei = as.numeric(Bare.nuclei),
Bl.cromatin = as.numeric(Bl.cromatin),
Normal.nucleoli = as.numeric(Normal.nucleoli),
Mitoses = as.numeric(Mitoses))
BreastCancer_num[is.na(BreastCancer_num)] = 0
train_classification <- BreastCancer_num[train_pos, ]
test_classification <- BreastCancer_num[-train_pos, ]
#fit a model
rfmodel = randomForest(Class ~ Id + Cl.thickness + Cell.size + Cell.shape + Marg.adhesion + Epith.c.size + Bare.nuclei + Bl.cromatin + Normal.nucleoli +  Mitoses, data=train_classification,  importance = TRUE, oob.times = 15, confusion = TRUE)
#rank features based on importance
importance(rfmodel)
#gives ranking for each feature
#loading data
data(Glass)
head(Glass)
dim(Glass)
Glass_num = transform(Glass, RI = as.numeric(RI),
Na = as.numeric(Na),
Mg = as.numeric(Mg),
Al = as.numeric(Al),
Si = as.numeric(Si),
K = as.numeric(K),
Ca = as.numeric(Ca),
Ba = as.numeric(Ba),
Fe = as.numeric(Fe),
Type = as.numeric(Type))
Glass_num[is.na(Glass_num)] = 0
#calculate correlation matrix using pearson correlation (others include spearman and kendall)
correlation_matrix = cor(Glass_num[,1:9])
#visualize correlation matrix
library(corrplot)
corrplot(correlation_matrix, order = "hclust")
#apply correlation filter of 0.7
highly_correlated <- colnames(Glass_num[, -1])[findCorrelation(correlation_matrix, cutoff = 0.7, verbose = TRUE)]
#which features are highly correlated and can be removed
highly_correlated
#define the control
control = rfeControl(functions = caretFuncs, number = 2)
# run the RFE algorithm
results = rfe(Glass_num[,1:9], Glass_num[,9], sizes = c(1,3,5), rfeControl = control, method = "svmRadial")
#sizes (2,5,9)/(2,5,7) can try different numbers
results
results$variables
#visualized
# plot(results, type=c('g','o'))
#list chosen features
predictors(results)
# stepwise backward regression
model <- lm(y ~ ., data = Glass)
# stepwise backward regression
step(lm(mpg~wt+drat+disp+qsec,data=Glass),direction="backward")
# stepwise backward regression
step(lm(Glass_num[,1:9],data=Glass),direction="backward")
# stepwise backward regression
results = step(lm(Glass_num[,1:9],data=Glass),direction="backward")
# stepwise backward regression
results = step(lm(Glass_num[,1:9],data=Glass),direction="backward")
results$fitted.values
# stepwise backward regression
results = step(lm(Glass_num[,1:9],data=Glass),direction="backward")
predictors(results)
